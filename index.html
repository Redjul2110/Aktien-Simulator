<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Aktien-Simulator</title>
  <style>
    :root{
      --bg:#0b0b0d;
      --panel:#0f1113;
      --muted:#9096a0;
      --accent:#0ef08a;
      --danger:#ff4d4f;
      --glass: rgba(255,255,255,0.03);
    }
    html,body{height:100%;}
    body {
      margin: 0;
      font-family: system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial;
      background: linear-gradient(180deg,var(--bg), #070708 110%);
      color: #e6eef6;
      display: flex;
      flex-direction: column;
      height: 100vh;
      padding-top: 64px; /* leave space for fixed header */
      -webkit-font-smoothing:antialiased;
    }

    /* Top bar */
    header.topbar{
      display:flex;align-items:center;justify-content:space-between;
      padding:12px 18px;background:linear-gradient(90deg,#071018 0%, #0b1115 100%);
      border-bottom:1px solid rgba(255,255,255,0.03);
  position:fixed;left:0;right:0;top:0;z-index:1400;-webkit-backdrop-filter: blur(4px);backdrop-filter: blur(4px);
    }
    
    
    header .title{font-weight:700;letter-spacing:0.4px}
    header .market-time{color:var(--muted);font-size:0.9rem}

    .balance{
      display:flex;align-items:center;gap:12px;padding:12px 18px;background:var(--panel);
      border-bottom:1px solid rgba(255,255,255,0.03);
    }
    .balance-controls{display:flex;gap:8px;}
  .balance .label{color:var(--muted);font-size:0.95rem}
  .balance .cash-row{display:flex;align-items:center;gap:12px}
  .balance .currency{color:var(--muted)}
  .balance .countdown-wrap{margin-left:auto}
    .balance .value{font-weight:700;font-size:1.15rem;color:var(--accent)}
    .balance .value.red{color:var(--danger)}
    .countdown{color:var(--muted);font-size:0.9rem}

    /* Main list */
    .accordion{flex:1;overflow:auto;padding:12px 18px;display:flex;flex-direction:column;gap:8px}
  .stock{background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);border-radius:8px;padding:8px;border:1px solid rgba(255,255,255,0.02);transition:transform .18s ease,box-shadow .18s ease}
  .stock.hovered{transform:translateY(-6px);box-shadow:0 14px 30px rgba(2,6,23,0.6);}
    /* per-stock accent: left border and title dot */
    .stock{--accent-color:var(--accent);border-left:6px solid transparent;padding-left:12px}
    .stock[data-accent]{border-left-color:var(--accent-color)}
    .chart-title::before{content:'';display:inline-block;width:10px;height:10px;border-radius:50%;background:var(--accent-color);margin-right:8px;box-shadow:0 0 12px var(--accent-color)}
    .stock-header{display:grid;grid-template-columns: 1fr 120px 100px 140px;gap:12px;align-items:center;cursor:pointer}
    .stock-header .preview{display:flex;align-items:center;gap:10px}
    .stock-header strong{font-size:0.98rem}
    .mini-chart{width:120px;height:36px;border-radius:4px;background:transparent;border:none}
    .price-text{font-variant-numeric:tabular-nums}
    .price-text.green{color:var(--accent)}
    .price-text.red{color:var(--danger)}
    .stock-header .change{color:var(--muted);font-size:0.9rem}

    .stock-content{display:none;padding:10px;margin-top:8px;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));border-radius:6px}
    canvas{width:100%;height:160px;border-radius:6px;background:transparent}

  /* Chart header inside expanded card */
  .chart-header{display:flex;align-items:center;justify-content:space-between;padding:6px 4px 10px 4px}
  .chart-header .chart-title{font-weight:700;font-size:1.05rem}
  .chart-header .chart-price{font-weight:700;font-size:1rem;color:var(--accent);display:flex;align-items:center;gap:8px}
  .chart-header .chart-price .arrow{font-size:0.85rem;color:var(--muted)}
  .chart-price.green{color:var(--accent)}
  .chart-price.red{color:var(--danger)}

    /* Controls */
    .controls{display:flex;gap:8px;align-items:center}
  input[type=number]{background:transparent;border:1px solid rgba(255,255,255,0.04);color:inherit;padding:8px;border-radius:6px}
  .qty-input{width:72px;padding:6px;border-radius:6px;border:1px solid rgba(39,74,122,0.12);background:rgba(8,32,55,0.14);color:inherit}
    button{background:transparent;border:1px solid rgba(255,255,255,0.06);color:inherit;padding:8px 12px;border-radius:6px;cursor:pointer}
    button.buy{background:linear-gradient(90deg,#042f14,#083b1f);border:1px solid rgba(0,240,138,0.12);color:var(--accent)}
    button.sell{background:linear-gradient(90deg,#3b0b0b,#2d0505);border:1px solid rgba(255,77,79,0.08);color:var(--danger)}

    .extra-controls{padding:10px 18px;background:var(--panel);display:flex;gap:12px;align-items:center;border-top:1px solid rgba(255,255,255,0.02)}
    .extra-controls button{background:transparent;border:1px solid rgba(255,255,255,0.03);padding:8px 10px;border-radius:6px}
  .extra-controls #tax-status{margin-left:8px;color:var(--muted)}
  .extra-controls #repayBtn{display:none}
    .loan-input{width:84px;padding:6px;border-radius:6px;background:transparent;border:1px solid rgba(255,255,255,0.06);color:inherit;margin-right:6px}
    .muted-label{color:var(--muted);margin-right:6px}
    .section-header{display:flex;gap:12px;align-items:center;margin-bottom:8px}
    .section-header h3{margin:0;color:var(--muted)}
    .section-btn{padding:6px;border-radius:6px}
    .section-wrap{padding:12px 18px}
    .section-list{margin-bottom:18px}

  footer{padding:12px 18px;background:transparent;color:var(--muted);font-size:0.85rem;text-align:center;position:fixed;left:0;right:0;bottom:0;z-index:1400;-webkit-backdrop-filter: blur(4px);backdrop-filter: blur(4px)}
    
    

    /* Gameover overlay */
    #gameover{position:fixed;inset:0;background:linear-gradient(180deg, rgba(0,0,0,0.85), rgba(0,0,0,0.92));color:var(--danger);display:none;z-index:999;align-items:center;justify-content:center;flex-direction:column}
    #gameover button{background:transparent;border:1px solid rgba(255,255,255,0.04);color:inherit;padding:10px 16px;border-radius:8px}
    /* Responsive: mobile layout improvements */
    @media (max-width: 720px){
      .stock-header{grid-template-columns: 1fr 90px 80px;grid-auto-rows:auto}
      .mini-chart{width:90px;height:30px}
      .stock{padding:10px}
      .controls{flex-direction:row;gap:6px;flex-wrap:wrap}
      .qty-input{width:60px}
      header.topbar{padding:10px}
      .balance{padding:10px}
      .extra-controls{flex-wrap:wrap;gap:8px}
      .stock.hovered{transform:none;box-shadow:none}
    }
    /* Pointer media: only enable hover lift on devices with fine pointer */
    @media (pointer: fine){
      .stock:hover{transform:translateY(-6px);box-shadow:0 14px 30px rgba(2,6,23,0.6)}
      button:hover{transform:translateY(-3px);box-shadow:0 10px 20px rgba(2,6,23,0.45)}
      button.buy:hover{filter:brightness(1.06)}
      button.sell:hover{filter:brightness(1.03)}
    }
  </style>
</head>
<body>
  <header class="topbar">
    <div class="title">üìà Aktien-Simulator</div>
    <div class="balance">
      <div class="cash-row">
        <div class="label">Bargeld</div>
        <div id="money" class="value">50</div>
        <div class="currency"> $</div>
      </div>
      <div class="countdown-wrap"><div id="countdown" class="countdown"></div></div>
      <div class="balance-controls">
        <button onclick="toggleSpeed()" id="speedBtn">‚è© x1</button>
        <button onclick="togglePause()" id="pauseBtn">‚è∏</button>
      </div>
    </div>
    <div class="market-time">Simulationsmodus ¬∑ Live</div>
  </header>

  <div class="section-wrap">
    <div class="section-header">
      <h3>Aktien</h3>
      <button class="section-btn" onclick="showOnly('stocks')">Nur Aktien</button>
      <button class="section-btn" onclick="showOnly('all')">Alle</button>
    </div>
    <div id="stocks-list" class="accordion section-list"></div>

    <div class="section-header">
      <h3>Kryptow√§hrungen</h3>
      <button class="section-btn" onclick="showOnly('crypto')">Nur Crypto</button>
    </div>
    <div id="crypto-list" class="accordion"></div>
  </div>

  <div class="extra-controls">
    <button onclick="resetGame()">üîÑ Zur√ºcksetzen</button>
    <button onclick="toggleSpeed()" id="speedBtn">‚è© x1</button>
    <button onclick="togglePause()" id="pauseBtn">‚è∏</button>
    <button onclick="saveGame()" id="saveBtn">üíæ Speichern</button>
    <button onclick="loadGame()" id="loadBtn">üìÇ Laden</button>
    <span id="tax-status"></span>
    <label for="loan-amt" class="muted-label">Kredit:</label>
    <input id="loan-amt" aria-label="Kreditbetrag" type="number" min="1" max="5000" value="200" class="loan-input">
    <button onclick="takeLoan()" id="loanBtn">üí∏ Kredit aufnehmen</button>
    <button onclick="repayLoan()" id="repayBtn">üí∞ Kredit zur√ºckzahlen</button>
    <button onclick="toggleMargin()" id="marginBtn">Margin: AN</button>
  </div>

  <div id="gameover">
    <div>üíÄ Du landest auf der Stra√üe!</div>
    <button onclick="resetGame(); hideGameOver();">Neustart</button>
  </div>

  <script>
  // Startgeld jetzt 50.00 $ (ausgeglichener)
  let money = 50.00;
    const moneyEl = document.getElementById("money");
    // initialize visible money
    moneyEl.textContent = money.toFixed(2);

    // Damping function for money changes near bounds
    function applyMoneyDamping(delta, currentMoney) {
      let factor = 1;
      if (currentMoney > 30 && delta > 0) {
        // reduce gains when above 30
        factor = Math.max(0.1, 1 - (currentMoney - 30) / 5);
      } else if (currentMoney < -5 && delta < 0) {
        // reduce losses when below -5
        factor = Math.max(0.1, 1 - (-5 - currentMoney) / 5);
      }
      return delta * factor;
    }
    const countdownEl = document.getElementById("countdown");
  const stocksList = document.getElementById("stocks-list");
  const cryptoList = document.getElementById("crypto-list");
    const gameoverEl = document.getElementById("gameover");

  let speeds = [1, 5, 10, 20];
  let speedIndex = 0;
  let speed = speeds[speedIndex];
  let tickInterval = 1500;
    let timerId = null;
    let paused = false;

  let debtDeadline = null;
  let debtTickerId = null;
  let debtRemainingWhenPaused = null;
  // Difficulty parameters
  const TRANSACTION_FEE_PCT = 0.005; // 0.5% fee per trade
  const SLIPPAGE_BASE = 0.002; // base slippage per share fraction
  const MARGIN_INTEREST_PCT_PER_TICK = 0.0015; // interest per tick on negative balance (~0.15%)
  const SHOCK_CHANCE_PER_TICK = 0.04; // ~4% chance per tick of a market shock
  const SHOCK_MAGNITUDE = 0.5; // shock moves price by up to +/-50%

    // helper: random start price between 15 and 25
    function randomStartPrice() { return +(15 + Math.random() * 10).toFixed(2); }

    // clamp price to range -200 to 500
    function clampPrice(price) {
      return Math.max(-200, Math.min(500, price));
    }

    // Stock model: start at a small random price so charts begin between 15 and 25
    const stocks = [
      { name: "RedJGames",     price: randomStartPrice(), prevPrice: null, owned: 0, history: [], volatility: 0.08, color: '#4da6ff', drift: -0.005 },
      { name: "AutoMax",      price: randomStartPrice(), prevPrice: null, owned: 0, history: [], volatility: 0.06, color: '#ffa64d', drift: -0.005 },
      { name: "Keppy",        price: randomStartPrice(), prevPrice: null, owned: 0, history: [], volatility: 0.06, color: '#ff4d4f', drift: -0.005 },
      { name: "GreenEnergy",  price: randomStartPrice(), prevPrice: null, owned: 0, history: [], volatility: 0.10, color: '#0ef08a', drift: -0.005 },
      { name: "Foodies",      price: randomStartPrice(), prevPrice: null, owned: 0, history: [], volatility: 0.05, color: '#ffd166', drift: -0.005 },
      // Crypto (fiktiv) ‚Äî h√∂here Volatilit√§t
      { name: "BitFiction",   price: +(20 + Math.random()*30).toFixed(2), prevPrice: null, owned: 0, history: [], volatility: 0.12, color: '#f7931a', isCrypto: true, drift: 0.0 },
      { name: "MoonToken",    price: +(8 + Math.random()*12).toFixed(2), prevPrice: null, owned: 0, history: [], volatility: 0.18, color: '#8a2be2', isCrypto: true, drift: 0.0 }
    ];

    // initialize histories from prices
    stocks.forEach(s => { s.prevPrice = s.price; s.history = [s.price]; });

    // UI
    stocks.forEach((stock, index) => {
      const stockDiv = document.createElement("div");
      stockDiv.className = "stock";
      const header = document.createElement("div");
      header.className = "stock-header";
      header.innerHTML = `
        <div class="preview">
          <strong>${stock.name}</strong>
          <canvas id="mini-${index}" class="mini-chart"></canvas>
        </div>
        <div>
          <span id="price-${index}" class="price-text">${formatPrice(stock.price)}</span>
          <span class="arrow" id="arrow-${index}">‚ñº</span>
        </div>`;
      const content = document.createElement("div");
      content.className = "stock-content";
      content.innerHTML = `
        <div class="chart-header">
          <div class="chart-title">${stock.name}</div>
          <div class="chart-price"><span id="price-large-${index}" class="price-text">${formatPrice(stock.price)}</span> <span class="arrow" id="arrow-large-${index}">‚ñº</span></div>
        </div>
        <p style="margin:8px 4px 6px 4px">Besitz: <span id="owned-${index}">0</span> St√ºck ¬∑ </p>
        <canvas id="chart-${index}"></canvas>
        <div class="controls" style="margin-top:10px">
          Menge: <input id="qty-${index}" class="qty-input" type="number" min="1" value="1"> 
          <button class="buy" onclick="buy(${index})">Kaufen</button>
          <button class="sell" onclick="sell(${index})">Verkaufen</button>
          <button class="sell-all" onclick="sellAll(${index})">Alle verkaufen</button>
        </div>`;
  header.addEventListener("click", () => {
    // If a touch handler just toggled this card, ignore the synthetic click
    if (window._lastTouchToggle && (Date.now() - window._lastTouchToggle) < 450) return;
    const isOpen = content.style.display === "block";
    content.style.display = isOpen ? "none" : "block";
    document.getElementById(`arrow-${index}`).textContent = isOpen ? "‚ñº" : "‚ñ≤";
  if (!isOpen) drawChart(`chart-${index}`, stocks[index].history, stocks[index].color || "#00ff99", true, stocks[index].price);
  });
  stockDiv.appendChild(header);
  stockDiv.appendChild(content);
  // append to stocks or crypto section
  if (stock.isCrypto) cryptoList.appendChild(stockDiv); else stocksList.appendChild(stockDiv);
      // set accent color on the stock container so CSS can style borders/dots
      (function(container, s){
        container.style.setProperty('--accent-color', s.color || 'var(--accent)');
        container.setAttribute('data-accent', '');
      })(stockDiv, stock);
    });

    // Formatierung + Farben
    function formatPrice(p) {
      const sign = p < 0 ? "-" : "";
      return `${sign}${Math.abs(p).toFixed(2)} $`;
    }
    function showOnly(mode){
      const s = document.getElementById('stocks-list');
      const c = document.getElementById('crypto-list');
      if(mode === 'stocks'){ s.style.display = ''; c.style.display = 'none'; }
      else if(mode === 'crypto'){ s.style.display = 'none'; c.style.display = ''; }
      else { s.style.display = ''; c.style.display = ''; }
    }
    function formatMoney(m){
      return Number(m).toFixed(2);
    }
    function setPriceColor(el, value) {
      el.classList.remove("green","red");
      el.classList.add(value >= 0 ? "green" : "red");
    }
    function updateMoneyColor() {
      moneyEl.classList.remove("green","red");
      moneyEl.classList.add(money >= 0 ? "green" : "red");
    }

    // Chart
  function drawChart(canvasId, data, color="#00ff99", withAxis=false, lastPrice=null, withGlow=false) {
      const canvas = document.getElementById(canvasId);
      if (!canvas) return;
      const ctx = canvas.getContext("2d");

      const rect = canvas.getBoundingClientRect();
      canvas.width = Math.floor(rect.width);
      canvas.height = Math.floor(rect.height);

      ctx.clearRect(0, 0, canvas.width, canvas.height);

  const min = Math.min(...data);
  const max = Math.max(...data);
      const range = Math.max(1e-6, max - min);
      const stepX = canvas.width / Math.max(1, data.length - 1);

      // gridlines for context (subtle)
      if (withAxis) {
        ctx.save();
        ctx.strokeStyle = 'rgba(200,200,200,0.06)';
        ctx.lineWidth = 1;
        ctx.setLineDash([4,6]);
        const gridLines = 4;
        for (let g=0; g<=gridLines; g++){
          const yy = (g/gridLines) * canvas.height;
          ctx.beginPath();
          ctx.moveTo(0.5, yy + 0.5);
          ctx.lineTo(canvas.width - 0.5, yy + 0.5);
          ctx.stroke();
        }
        ctx.restore();
      }

      // draw main price line
      ctx.beginPath();
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.lineJoin = 'round';
      for (let i=0;i<data.length;i++){
        const p = data[i];
        const x = i * stepX;
        const y = canvas.height - ((p - min) / range) * canvas.height;
        if (i===0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
      }
      ctx.stroke();

      // optional glow highlight
      if (withGlow) {
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.shadowBlur = 18;
        ctx.shadowColor = color;
        ctx.lineWidth = 4;
        ctx.strokeStyle = color;
        ctx.stroke();
        ctx.restore();
      }

      // last point marker + label
      const last = data[data.length - 1];
      const xLast = (data.length - 1) * stepX;
      const yLast = canvas.height - ((last - min) / range) * canvas.height;
      const label = formatPrice(lastPrice ?? last);

      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(xLast, yLast, 3, 0, Math.PI * 2);
      ctx.fill();

  ctx.font = '12px Arial';
  const textWidth = ctx.measureText(label).width;
  // draw label directly without background box to avoid gray stripe
  const textX = Math.min(canvas.width - textWidth - 6, Math.max(6, xLast + 8));
  const textY = Math.min(canvas.height - 14, Math.max(4, yLast - 9));
  ctx.fillStyle = (last >= 0) ? '#00ff66' : '#ff3333';
  ctx.textBaseline = 'top';
  ctx.fillText(label, textX, textY);

      // Additional overlays when withAxis=true: Fibonacci retracements and trendline
      if (withAxis) {
        // Fibonacci levels (0.786,0.618,0.5,0.382,0.236)
        const fibs = [0.786, 0.618, 0.5, 0.382, 0.236];
        ctx.save();
        ctx.lineWidth = 1;
        ctx.setLineDash([6,6]);
        for (let i=0;i<fibs.length;i++){
          const f = fibs[i];
          const level = max - f * (max - min);
          const y = canvas.height - ((level - min) / range) * canvas.height;
          ctx.beginPath();
          // neutral gray fib lines
          ctx.strokeStyle = `rgba(200,200,200,${0.05 + i*0.02})`;
          ctx.moveTo(0.5, y + 0.5);
          ctx.lineTo(canvas.width - 0.5, y + 0.5);
          ctx.stroke();
          // tiny label
          ctx.fillStyle = 'rgba(200,200,200,0.32)';
          ctx.fillText(level.toFixed(2) + ' $', 6, Math.max(10, y - 6));
        }
        ctx.restore();

        // trendline removed by user request (no diagonal stripe)
      }
    }

    // Mini-Charts initialisieren
    function initMiniCharts() {
      stocks.forEach((s, i) => {
  drawChart(`mini-${i}`, s.history.slice(-10), s.color || "#00ff66", false, null, false);
      });
    }

    // Kurs-Ticker: Prozentuale Bewegungen mit normalverteilter Zufallsstreuung
    function gaussianRandom() {
      // Box-Muller
      let u = 0, v = 0;
      while(u === 0) u = Math.random();
      while(v === 0) v = Math.random();
      return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
    }

    function tick() {
      if (paused) return;

      stocks.forEach((stock, i) => {
  stock.prevPrice = stock.price;
  // neutral drift to allow prices to go up or down
  const drift = stock.drift || 0.0;
        const vol = stock.volatility || 0.03;
        const pct = drift + gaussianRandom() * vol; // e.g. -0.1..+0.1 typical

    // apply percent movement, adjusted to allow going negative from 0
  stock.price = (stock.price + 1) * (1 + pct) - 1;

        // occasional market shock affecting all stocks
        if (Math.random() < SHOCK_CHANCE_PER_TICK) {
          const shockDir = (Math.random() < 0.5) ? -1 : 1;
          const mag = Math.random() * SHOCK_MAGNITUDE;
          stock.price = stock.price * (1 + shockDir * mag);
        }

        // clamp price to range -1000000 to 5000000
        stock.price = clampPrice(stock.price);
        stock.history.push(stock.price);
        if (stock.history.length > 120) stock.history.shift();

        const headerPriceEl = document.getElementById(`price-${i}`);
        const largePriceEl  = document.getElementById(`price-large-${i}`);
        const largeArrowEl  = document.getElementById(`arrow-large-${i}`);
        if (headerPriceEl) {
          headerPriceEl.textContent = formatPrice(stock.price);
          // color by relative change
          const diff = stock.price - stock.prevPrice;
          setPriceColor(headerPriceEl, diff);
        }
        if (largePriceEl) {
          largePriceEl.textContent = formatPrice(stock.price);
          const diff = stock.price - stock.prevPrice;
          setPriceColor(largePriceEl, diff);
          if(largeArrowEl) largeArrowEl.textContent = diff >= 0 ? '‚ñ≤' : '‚ñº';
          // chart-header price color
          const chartPriceWrap = largePriceEl.closest('.chart-price');
          if(chartPriceWrap){
            chartPriceWrap.classList.toggle('green', diff >= 0);
            chartPriceWrap.classList.toggle('red', diff < 0);
          }
        }

  drawChart(`mini-${i}`, stock.history.slice(-18), stock.color || "#00ff66", false, null, false);

        const content = document.querySelectorAll('.stock-content')[i];
        if (content && content.style.display === "block") {
          // only show glow on larger moves (>1%)
          const prev = stock.history[stock.history.length-2] ?? stock.history[stock.history.length-1];
          const pct = prev ? Math.abs((stock.price - prev) / Math.abs(prev)) : 0;
          drawChart(`chart-${i}`, stock.history, stock.color || "#00ff99", true, stock.price, pct > 0.01);
        }
      });

      updateMoneyColor();

      // Apply margin interest on negative balances only when not paused and no debt countdown is active
      if (money < 0 && !paused && !debtDeadline) {
        // interest rounded to cents
        const interest = Math.ceil(Math.abs(money) * MARGIN_INTEREST_PCT_PER_TICK * 100) / 100;
        money -= interest; // increase debt
        moneyEl.textContent = formatMoney(money);
        updateMoneyColor();
      }

      checkDebtTimer();
    }

    // Funktion zum Aktualisieren der Preis-UI f√ºr einen Stock
    function updatePriceUI(i) {
      const headerPriceEl = document.getElementById(`price-${i}`);
      const largePriceEl = document.getElementById(`price-large-${i}`);
      const largeArrowEl = document.getElementById(`arrow-large-${i}`);
      if (headerPriceEl) {
        headerPriceEl.textContent = formatPrice(stocks[i].price);
        const diff = stocks[i].price - stocks[i].prevPrice;
        setPriceColor(headerPriceEl, diff);
      }
      if (largePriceEl) {
        largePriceEl.textContent = formatPrice(stocks[i].price);
        const diff = stocks[i].price - stocks[i].prevPrice;
        setPriceColor(largePriceEl, diff);
        if (largeArrowEl) largeArrowEl.textContent = diff >= 0 ? '‚ñ≤' : '‚ñº';
        const chartPriceWrap = largePriceEl.closest('.chart-price');
        if (chartPriceWrap) {
          chartPriceWrap.classList.toggle('green', diff >= 0);
          chartPriceWrap.classList.toggle('red', diff < 0);
        }
      }
      drawChart(`mini-${i}`, stocks[i].history.slice(-18), stocks[i].color || "#00ff66", false, null, false);
      const content = document.querySelectorAll('.stock-content')[i];
      if (content && content.style.display === "block") {
        const prev = stocks[i].history[stocks[i].history.length - 2] ?? stocks[i].history[stocks[i].history.length - 1];
        const pct = prev ? Math.abs((stocks[i].price - prev) / Math.abs(prev)) : 0;
        drawChart(`chart-${i}`, stocks[i].history, stocks[i].color || "#00ff99", true, stocks[i].price, pct > 0.01);
      }
    }

    // Kaufen: immer absoluter Preis -> Geld wird abgezogen
    function buy(i) {
      const price = Math.abs(stocks[i].price);
      const qtyEl = document.getElementById(`qty-${i}`);
      const qty = Math.max(1, parseInt(qtyEl?.value || 1, 10));
      // slippage depends on qty and volatility
      const slippage = 1 + SLIPPAGE_BASE * qty * (stocks[i].volatility || 0.03) * 10;
      const grossCost = price * qty * slippage;
      const fee = grossCost * TRANSACTION_FEE_PCT;
      // round to cents
      const total = Math.round((grossCost + fee) * 100) / 100;

      money = Math.round((money - total) * 100) / 100;
      stocks[i].owned += qty;
      // small downward price nudge on buy ‚Äî small 1 $ decrease, tempor√§r f√ºr 2 Sekunden
      const nudge = 1; // 1 $
      const originalPrice = stocks[i].price;
      stocks[i].price = Math.round((stocks[i].price - nudge) * 100) / 100;
      // Nach 2 Sekunden Preis zur√ºcksetzen
      setTimeout(() => {
        stocks[i].price = originalPrice;
        updatePriceUI(i);
      }, 2000);

      moneyEl.textContent = formatMoney(money);
      updateMoneyColor();
      document.getElementById(`owned-${i}`).textContent = stocks[i].owned;
      checkDebtTimer();
    }

    // Verkaufen: immer absoluter Preis -> Geld wird gutgeschrieben
    function sell(i) {
      const price = Math.abs(stocks[i].price);
      const qtyEl = document.getElementById(`qty-${i}`);
      const qty = Math.max(1, parseInt(qtyEl?.value || 1, 10));
      const sellQty = Math.min(qty, stocks[i].owned);
      if (sellQty <= 0) return;
  let slippage = 1 - SLIPPAGE_BASE * sellQty * (stocks[i].volatility || 0.03) * 10;
  // cap slippage to a reasonable range
  if (slippage < 0.5) slippage = 0.5;
  if (slippage > 1.5) slippage = 1.5;
      const grossProceeds = price * sellQty * Math.max(0.5, slippage);
      const fee = grossProceeds * TRANSACTION_FEE_PCT;
      // round to cents
      const total = Math.round((grossProceeds - fee) * 100) / 100;
      stocks[i].owned -= sellQty;
      money = Math.round((money + total) * 100) / 100;
      moneyEl.textContent = formatMoney(money);
      updateMoneyColor();
      document.getElementById(`owned-${i}`).textContent = stocks[i].owned;
      checkDebtTimer();
    }

    // Sell entire holding for stock i
    function sellAll(i) {
      const price = Math.abs(stocks[i].price);
      const sellQty = stocks[i].owned;
      if (sellQty <= 0) return;
  let slippage = 1 - SLIPPAGE_BASE * sellQty * (stocks[i].volatility || 0.03) * 10;
  if (slippage < 0.5) slippage = 0.5;
  if (slippage > 1.5) slippage = 1.5;
  const grossProceeds = price * sellQty * slippage;
      const fee = grossProceeds * TRANSACTION_FEE_PCT;
      const total = Math.round((grossProceeds - fee) * 100) / 100;
      stocks[i].owned = 0;
      money = Math.round((money + total) * 100) / 100;
      moneyEl.textContent = formatMoney(money);
      updateMoneyColor();
      document.getElementById(`owned-${i}`).textContent = stocks[i].owned;
      checkDebtTimer();
    }

    // Reset: Markt zur√ºck auf 0, Geld wieder 50
    function resetGame() {
      money = 50.00;
      moneyEl.textContent = money.toFixed(2);
      updateMoneyColor();
      hideGameOver();
      debtDeadline = null;
      stopDebtCountdown();
      countdownEl.textContent = "";

      stocks.forEach((s, i) => {
  s.price = Math.random() < 0.05 ? -randomStartPrice() : randomStartPrice();
  s.prevPrice = s.price;
  s.owned = 0;
  s.history = [s.price];
        document.getElementById(`owned-${i}`).textContent = 0;

        const headerPriceEl = document.getElementById(`price-${i}`);
        const largePriceEl  = document.getElementById(`price-large-${i}`);
        if (headerPriceEl) {
          headerPriceEl.textContent = formatPrice(s.price);
          setPriceColor(headerPriceEl, s.price);
        }
        if (largePriceEl) {
          largePriceEl.textContent = formatPrice(s.price);
          setPriceColor(largePriceEl, s.price);
        }

    drawChart(`mini-${i}`, s.history, s.color || "#00ff66", false, null, false);
  drawChart(`chart-${i}`, s.history, s.color || "#00ff99", true, s.price, false);
      });
    }

    // Geschwindigkeit toggeln
    function toggleSpeed() {
      speedIndex = (speedIndex + 1) % speeds.length;
      speed = speeds[speedIndex];
      document.getElementById("speedBtn").textContent = `‚è© x${speed}`;
      restartTimer();
    }

    // Pause toggeln
    function togglePause() {
      paused = !paused;
      document.getElementById("pauseBtn").textContent = paused ? "‚ñ∂ Fortsetzen" : "‚è∏ Pause";
      if (paused) {
        // freeze debt deadline
        if (debtDeadline) {
          debtRemainingWhenPaused = Math.max(0, debtDeadline - Date.now());
          stopDebtCountdown();
        }
        // freeze loan deadline
        if (loanDeadline) {
          loanRemainingWhenPaused = Math.max(0, loanDeadline - Date.now());
          stopLoanTicker();
        }
      } else {
        // resume debt deadline
        if (debtRemainingWhenPaused != null) {
          debtDeadline = Date.now() + debtRemainingWhenPaused;
          debtRemainingWhenPaused = null;
          startDebtCountdown();
        }
        // resume loan deadline
        if (typeof loanRemainingWhenPaused !== 'undefined' && loanRemainingWhenPaused != null) {
          loanDeadline = Date.now() + loanRemainingWhenPaused;
          loanRemainingWhenPaused = null;
          startLoanTicker();
        }
      }
    }

    function restartTimer() {
      if (timerId) clearInterval(timerId);
      const interval = Math.max(150, Math.floor(tickInterval / speed));
      timerId = setInterval(tick, interval);
    }

    // Minus-Geld Countdown (30s, ‚ÄûDu landest auf der Stra√üe‚Äú)
    function checkDebtTimer() {
      if (money < 0 && !debtDeadline) {
        debtDeadline = Date.now() + 30 * 1000; // 30 Sekunden
        startDebtCountdown();
      } else if (money >= 0 && debtDeadline) {
        debtDeadline = null;
        stopDebtCountdown();
        countdownEl.textContent = "";
        hideGameOver();
      }
    }
    function startDebtCountdown() {
      stopDebtCountdown();
      updateCountdownText();
      debtTickerId = setInterval(updateCountdownText, 1000);
    }
    function stopDebtCountdown() {
      if (debtTickerId) clearInterval(debtTickerId);
      debtTickerId = null;
    }
    function updateCountdownText() {
      if (!debtDeadline) return;
      const remaining = debtDeadline - Date.now();
      if (remaining <= 0) {
        // clear save on death
        clearSave();
        showGameOver();
        return;
      }
      const secs = Math.floor(remaining / 1000);
      countdownEl.textContent = `(Reset in ${secs}s)`;
    }

    function showGameOver() {
      // ensure save cleared and timers stopped
      clearSave();
      stopDebtCountdown();
      stopTaxTimer();
      stopLoanTicker();
      gameoverEl.style.display = "flex";
    }
    function hideGameOver() {
      gameoverEl.style.display = "none";
    }

    // Start
    initMiniCharts();
    updateMoneyColor();
    restartTimer();
  </script>
  <script>
    // Tax and Loan system
    const TAX_INTERVAL_MS = 3 * 60 * 1000; // 3 minutes
    const TAX_AMOUNT = 2.00; // flat tax for simplicity
    let taxTimerId = null;
    let missedTaxes = 0;

    // Loan
    let loanActive = false;
    let loanAmount = 0;
    let loanDeadline = null; // timestamp
    let loanTickerId = null;
  let loanRemainingWhenPaused = null;

    function startTaxTimer(){
      stopTaxTimer();
      taxTimerId = setInterval(()=>{ if(!paused) chargeTax(); }, TAX_INTERVAL_MS);
      updateTaxUI();
    }
    function stopTaxTimer(){ if(taxTimerId) clearInterval(taxTimerId); taxTimerId = null; }

    function chargeTax(){
      // attempt to charge; if can't pay, increment missed counter
      if(money >= TAX_AMOUNT){
        money = Math.round((money - TAX_AMOUNT) * 100) / 100;
        moneyEl.textContent = formatMoney(money);
        toast('Steuern bezahlt');
        missedTaxes = 0;
      } else {
        missedTaxes++;
        toast(`Steuern nicht bezahlt (${missedTaxes}/3)`);
        if(missedTaxes >= 3){
          clearSave();
          showGameOver();
        }
      }
      updateMoneyColor();
      updateTaxUI();
    }

    function updateTaxUI(){
      const el = document.getElementById('tax-status');
      if(!el) return;
      el.textContent = `Steuer: ${TAX_AMOUNT.toFixed(2)} $ ¬∑ verpasst: ${missedTaxes}`;
    }

    // Loan & margin
    let marginEnabled = true;
    function toggleMargin(){
      marginEnabled = !marginEnabled;
      document.getElementById('marginBtn').textContent = 'Margin: ' + (marginEnabled ? 'AN' : 'AUS');
      toast('Margin ' + (marginEnabled ? 'aktiviert' : 'deaktiviert'));
    }

    function takeLoan(){
      if(loanActive){ toast('Du hast bereits einen Kredit'); return; }
      const input = document.getElementById('loan-amt');
      const amt = Math.max(1, Math.min(5000, parseFloat(input?.value || 200)));
      loanActive = true;
      loanAmount = Math.round(amt * 100) / 100;
      money = Math.round((money + loanAmount) * 100) / 100;
      moneyEl.textContent = formatMoney(money);
      document.getElementById('loanBtn').style.display = 'none';
      document.getElementById('repayBtn').style.display = 'inline-block';
      // set 30 minutes deadline from now
      loanDeadline = Date.now() + 30 * 60 * 1000;
      startLoanTicker();
      toast(`Kredit erhalten: +${loanAmount}`);
    }

    function repayLoan(){
      if(!loanActive) return;
      const required = Math.round((loanAmount + 200) * 100) / 100; // +200 fee
      if(money >= required){
        money = Math.round((money - required) * 100) / 100;
        loanActive = false; loanAmount = 0;
        // stop and clear deadline
        stopLoanTicker();
        loanDeadline = null;
        // clear countdown UI
        countdownEl.textContent = '';
        document.getElementById('loanBtn').style.display = 'inline-block';
        document.getElementById('repayBtn').style.display = 'none';
        moneyEl.textContent = formatMoney(money);
        updateMoneyColor();
        toast(`Kredit zur√ºckgezahlt (inkl. Geb√ºhr 200 $)`);
      } else {
        toast(`Nicht genug Geld zum Zur√ºckzahlen. Ben√∂tigt: ${required.toFixed(2)} $`);
      }
    }

    function startLoanTicker(){
      stopLoanTicker();
      loanTickerId = setInterval(()=>{ if(!paused) updateLoanTick(); }, 1000);
    }
    function stopLoanTicker(){ if(loanTickerId) clearInterval(loanTickerId); loanTickerId = null; }

    function updateLoanTick(){
      if(!loanActive || !loanDeadline) return;
      const rem = loanDeadline - Date.now();
      if(rem <= 0){
        // default: death if not repaid
        clearSave();
        showGameOver();
        return;
      }
      // optionally show loan time somewhere (reuse countdownEl)
      const mins = Math.floor(rem / 60000);
      const secs = Math.floor((rem % 60000)/1000);
      countdownEl.textContent = `Kredit f√§llig in ${mins}m ${secs}s`;
    }

    // Ensure pause also suspends death/tax/loan timers visually
    const origTogglePause = togglePause;
    function togglePause(){
      paused = !paused;
      document.getElementById("pauseBtn").textContent = paused ? "‚ñ∂ Fortsetzen" : "‚è∏ Pause";
      // when paused, stop applying interest and suspend loan/tax countdown effects visually
      if(paused){
        // no-op: timers already check paused flag
      } else {
        // resume loan ticker updates immediately to refresh UI
        if(loanActive) updateLoanTick();
      }
    }

    // start tax timer on load
    startTaxTimer();
  </script>
  <script>
    // Persistence (localStorage)
    const SAVE_KEY = 'aktien_sim_save_v1';

    function getGameState(){
      return {
        money,
        stocks: stocks.map(s=>({name:s.name,price:s.price,owned:s.owned,history:s.history,volatility:s.volatility}))
      };
    }

    function applyState(state){
      if(!state) return;
      money = state.money ?? money;
      moneyEl.textContent = money;
      state.stocks?.forEach((s,i)=>{
        if(stocks[i]){
          stocks[i].price = s.price ?? stocks[i].price;
          stocks[i].owned = s.owned ?? stocks[i].owned;
          stocks[i].history = s.history && s.history.length? s.history : stocks[i].history;
          const ownedEl = document.getElementById(`owned-${i}`);
          const priceEl = document.getElementById(`price-${i}`);
          const largeEl = document.getElementById(`price-large-${i}`);
          if(ownedEl) ownedEl.textContent = stocks[i].owned;
          if(priceEl) { priceEl.textContent = formatPrice(stocks[i].price); setPriceColor(priceEl, stocks[i].price - stocks[i].prevPrice); }
          if(largeEl) { largeEl.textContent = formatPrice(stocks[i].price); setPriceColor(largeEl, stocks[i].price - stocks[i].prevPrice); }
        }
      });
      initMiniCharts();
      toast('Spiel geladen');
    }

    function saveGame(){
      try{
        const state = getGameState();
        localStorage.setItem(SAVE_KEY, JSON.stringify(state));
        toast('Spiel gespeichert');
      }catch(e){
        toast('Speichern fehlgeschlagen');
        console.error(e);
      }
    }

    function loadGame(){
      try{
        const raw = localStorage.getItem(SAVE_KEY);
        if(!raw){ toast('Kein Save gefunden'); return; }
        const state = JSON.parse(raw);
        applyState(state);
      }catch(e){ toast('Laden fehlgeschlagen'); console.error(e); }
    }

    function clearSave(){ localStorage.removeItem(SAVE_KEY); toast('Save gel√∂scht'); }

    // auto-save every 30s
    setInterval(()=>{ try{ localStorage.setItem(SAVE_KEY, JSON.stringify(getGameState())); }catch(e){} }, 30000);

    // small toast helper
    function toast(msg, timeout=1800){
      let t = document.getElementById('sim-toast');
      if(!t){ t = document.createElement('div'); t.id = 'sim-toast'; t.style.position='fixed'; t.style.right='18px'; t.style.bottom='18px'; t.style.padding='10px 14px'; t.style.background='linear-gradient(90deg,#0b1113,#111214)'; t.style.border='1px solid rgba(255,255,255,0.04)'; t.style.borderRadius='8px'; t.style.color='var(--muted)'; t.style.zIndex='1100'; document.body.appendChild(t); }
      t.textContent = msg;
      t.style.opacity = '1';
      setTimeout(()=>{ t.style.opacity='0'; }, timeout);
    }
  </script>
  <script src="./style.js"></script>
</body>
</html>

